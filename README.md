# Шпаргалка git  

## **Команды для git**

* log - логи коммитов (флаг --oneline - укороченная история коммитов)

```bash
git log
```  

* add - добавление файлов в коммит (флаг --all || или отдельное название файлов)

```bash
git add --all
```  

* commit - добавление в истории изменений (флаг -m сообщение в скобках "")

```bash
git commit -m "Информация о проделанном в краце"
```  

* commit --amend - редактирование коммита (флаг --no-edit Благодаря опции --no-edit сообщение к коммиту останется таким, каким и было.   флаг -m "Новое сообщение" - нужен для изменения сообщения )

```bash
git add main.html # добавили в список на коммит
git commit --amend --no-edit
```

* push - добавление в удаленный репозиторий  

```bash
git push
```

* restored - откат файлов в коммитах  

Команда переведёт файл из staged обратно в modified или untracked.

```bash
git restore --staged <file>
```

Команда «откатит» изменения в файле до последней сохранённой (в коммите или в staging) версии.

```bash
git restore <file>
```

* reset - откат коммита

Команда «откатит» историю до коммита с хешем . Более поздние коммиты потеряются!

```bash
git reset --hard <commit hash>
```

* diff - вывод изменений в файлах

Команда git diff сравнит последнюю закоммиченную версию файла с той, что находится в состоянии modified.

```bash
git diff
```

Команда git diff --staged покажет изменения в staged-файлах относительно последних закоммиченных версий.

```bash
git diff --staged
```

---

## **Дополнение**  

1. Синхронизация локального и удалённого репозиториев

```bash
git remote add origin <Ссылка на удаленный репозиторий>
git remote -v # Проверяем связь между репозиториями
git push -u origin main # Может быть либо main, либо master
```

2. [Ссылка](https://github.com/Kollo4455 "Мой профиль")

3. Клонирование репозитория

```bash
git clone %ССЫЛКА НА РЕПОЗИТОРИЙ%
cd %ИМЯ РЕПОЗИТОРИЯ%
git remote -v
```

4. Форк репозитория

Нажать на кнопку fork в репозитории github

```bash
git clone %SSH скопированного репозитория%
```

---

## **Хэш**  

1. Git преобразует информацию о коммитах с помощью алгоритма SHA-1 и для каждого из них рассчитывает уникальный идентификатор — хеш.

2. Хеш — основной идентификатор коммита и позволяет узнать его автора, дату и содержимое закоммиченных файлов.

3. Все хеши, а также таблицу соответствий хеш → информация о коммите Git хранит в папке .git.

---

## **Логи**

* Можно вызвать не только полный лог, но и сокращённый — это делается командой.

```bash
git log --oneline.
```

* В сокращённом логе выводятся сокращённые хеши — их можно использовать точно так же, как и полные.

---

## **Head**

* В числе прочих файлов в папке .git есть служебный файл HEAD. Он указывает на самый свежий коммит.  

* Вместо хеша последнего коммита можно написать слово HEAD — Git вас поймёт.  

---

## **Статусы**

* Статусом untracked помечается файл, о существовании которого Git знает, но не следит за изменениями в нём. Этот статус — противоположность tracked, в который попадают все файлы, отслеживаемые Git.  

* Файл переходит в статус staged после выполнения git add.  

* Статус modified означает, что файл был изменён.  

* Большинство файлов в проектах «шагает» по следующему циклу: «изменён» → «добавлен в список на коммит» → «закоммичен» → «изменён» → и так далее.

---

## **Чтение статусов**

* Команда git status всегда подскажет, что происходит с файлом: например, он добавлен в список «на коммит» или ещё вообще не отслеживается, или изменён.

* git status показывает явно следующие состояния файлов: untracked, staged и modified.

* git status подсказывает, какие команды можно выполнить, чтобы поменять состояние файла.

---

## **Оформление сообщений к коммитам**

* Все люди разные и у всех есть предпочтения — в том числе, как формулировать сообщения коммитов. Кто-то использует инфинитивы: Исправить сообщение об ошибке E123, кто-то — глаголы в прошедшем времени: Исправил…, кто-то — существительные: Исправление….

* выводе команды git log --oneline умещается максимум 72 первых символа сообщения, поэтому многие правила включают пункт: «Сообщение не должно быть длиннее 72 символов».

---

## Клонирование чужого репозитория

* git clone <git@github.com>:YandexPraktikum/first-project.git (от англ. clone, «клон», «копия») — склонируй репозиторий с URL first-project.git из аккаунта YandexPraktikum на мой локальный компьютер.

---

## Создание веток

* git branch feature/the-finest-branch (от англ. branch, «ветка») — создай ветку от текущей с названием feature/the-finest-branch

* git checkout -b feature/the-finest-branch — создай ветку feature/the-finest-branch и сразу переключись на неё.

---

## Навигация по веткам

* git branch (от англ. branch, «ветка») — покажи, какие есть ветки в репозитории и в какой из них я нахожусь (текущая ветка будет отмечена символом *)

* git branch -a — покажи все известные ветки, как локальные (в локальном репозитории), так и удалённые (в origin, или на GitHub).

* git checkout feature/br — переключись на ветку feature/br.

---

## Сравнение веток

* git diff main HEAD (от англ. difference, «отличие», «разница») — покажи разницу между веткой main и указателем на HEAD

* git diff HEAD~2 HEAD — покажи разницу между тем коммитом, который был два коммита назад, и текущим.

---

## Удаление веток

* git branch -d br-name — удали ветку br-name, но только если она является частью main

* git branch -D br-name — удали ветку br-name, даже если она не объединена с main.

---

## Слияние веток

* git merge main (от англ. merge, «сливать», «поглощать») — объедини ветку main с текущей активной веткой.

---

## Работа с удаленным репозиторием

* git push -u origin my-branch (от англ. push, «толкнуть», «протолкнуть») — отправь новую ветку my-branch в удалённый репозиторий и свяжи локальную ветку с удалённой, чтобы при дополнительных коммитах можно было писать просто git push без -u.

* git push my-branch — отправь дополнительные изменения в ветку my-branch, которая уже существует в удалённом репозитории.

* git pull (от англ. pull, «вытянуть») — подтяни изменения текущей ветки из удалённого репозитория.
